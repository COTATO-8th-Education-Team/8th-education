# 동시성 프로그래밍

# 개요

- 인사말
- 동시성 프로그래밍
- 동기, 비동기
- 블로킹, 논블로킹
- 블로킹 논블로킹 동기 비동기 조합
- 사용
- Race Condition

# 동시성 프로그래밍(concurrent programming)

예를들어 2명에서 일하는 카페가 있습니다. 커피주문이 들어왔을 때 가장빨리 
커피를 내보내는 방법은 무엇일까요? 바로 한명은 얼음을 푸고 한명은 커피를 
내리는 것입니다. 이 작업들은 각자 동시에 발생하게되고 마지막에 결과물로 
동기화 됩니다.

한명에서 순차적으로 작업을 처리하는 것보다 훨씬 효율적인 운영이라고 볼 수 
있습니다.

이 개념은 컴퓨터가 일을 처리하는 방식에도 적용할 수 있고 동시성 
프로그래밍이라고 합니다.

동시성 프로그래밍을 구현하기 위해서는 알아야하는 개념들이 있습니다. 

바로 동기 비동기 블로킹 논블로킹 이라는 개념입니다.

# 동기 비동기(synchronous / asynchronous)

우선 동기 비동기 부터 살펴보겠습니다.

두개이상의 작업을 처리해야할 때 해당 작업들을 처리하는 방식은 크게 
동기적으로 처리할 것인가 아니면 비동기적으로 처리할 것인가로 나뉠 수 
있습니다.

일단 두개념은 한가지 기준을 통해 구분될 수 있습니다.

**바로 한 작업을 요청했을 때 해당 작업의 완료 여부를 확인하는 것입니다.**

작업의 완료여부를 확인한다는 것은 해당 작업을 현재 작업과 동기화 시키기 
위해서라고 이해할 수 있습니다.

앞서 언급한 카페알바생 예시를 다시한번 살펴보겠습니다.

주문이 들어온 후 알바생1은 알바생2에게 얼음을 풀것을 지시합니다.

여기서 알바생2가 얼음을 다 푼 것을 확인한 이후에 알바생1이 커피를 내리기 
시작한다면 

이것은 동기성 특징이라고 할 수 있습니다. 

왜냐하면 얼음을 푸는 작업의 완료여부를 확인하였기 때문입니다.

하지만 알바생1은 알바생2가 얼음을 엎지르던 말던 우선 커피를 내릴 수도 
있습니다. 지시한 작업의 완료여부를 상관하지 않는다는 의미지요. 이 경우 
얼음을 푸는 작업은 비동기적으로 수행된다고 말할 수 있습니다.

간단한 Swift코드로 해당기능을 살펴보겠습니다.

`waitUntilFinished` 부분을 보시면 `false` 로 설정되어 있는 것을 확인하실 
수 있습니다.

즉, 이 작업의 완료여부를 기다리지 않겠다, 비동기적으로 작업을 처리하겠다는 
의미입니다.

```swift
func makeCoffee() {
    for index in 0..<6 {
        print("커피 내림☺️: \(20 * index)%")
        sleep(1)
    }
		print("알바생1: 커피다내렸어요!!")
}

func scoopIce() {
    for index in 0..<5 {
        print("얼음 푸기❄️: \(25 * index)%")
        sleep(1)
    }
}

var iceOperation = BlockOperation(block: scoopIce)
iceOperation.completionBlock = {
    print("알바생1: 얼음을 다펐습니다!!")
}

//알바생2: 알바생1님 얼음푸세여!
OperationQueue().addOperations([iceOperation], waitUntilFinished: false)

//알바생2: 저는 커피를 내릴게요!
makeCoffee()
```

얼음푸는 작업의 완료여부와 상관없이 커피를 내리는 작업이 진행된다는 것을 
확인할 수 있습니다.

완료여부를 따로 확인하지 않는데 그럼 해당 작업의 끝을 어떻게 알 수 있을 
까요?

보통은 해당 작업이 끝나면 호출되는 코드블록을 전달하는 방식으로 
구현합니다. callback함수라고 보통 불립니다. 작업이 끝나느 경우 전달한 
callback함수가 호출되게 되는 것이지요.

위코드도 화면에 보이시는 부분을 통해 callback불록을 전달한 것을 확인할 수 
있고 작업 종료후 호출된 것도 확인할 수 있습니다.

```swift
iceOperation.completionBlock = {
    print("알바생1: 얼음을 다펐습니다!!")
}
```

# 블로킹 / 논블로킹 (blocking / nonblocking)

블로킹 단어 그자체로 뭔가를 막는다라는 의미가 있습니다.

블로킹과 논블로킹은 다음 기준으로 구분 될 수 있습니다.

실행하려고 하는 작업이 현재 작업을 중단시키는가?  

중단시킬경우 블로킹 중단시키지 않을 경우 논블로킹이라고 합니다.

카페알바 예제를 다시한번 살펴보겠습니다.

이번에는 둘이 아니라 혼자서 일하는 상황을 가정해볼게요.

혼자서 일하는 상황에서는 얼음을 내리는 동시에 커피를 내릴 수 없습니다. 즉, 
커피를 내리는 작업이 블로킹 되어있는 상태라고 할 수 있습니다.

코드를 보면 다음과 같습니다.

```swift
var iceOperation = BlockOperation(block: scoopIce)

OperationQueue().addOperations([iceOperation], waitUntilFinished: true)
//블로킹 시작지점

makeCoffee()
```

논블로킹의 경우 앞서 알바생1과 알바생2가 각자 자신의 작업을 동시에 
처리하는 경우입니다.

얼음을 푸는 작업이 커피를 내리는 작업을 막지 못하는 것이지요.

# 블로킹과 동기성의 차이점

이쯤되면 그럼 동기성과 블로킹은 무슨 차이가 있는 거지 라는 의문이 들 수 
있습니다. 

왜냐면 앞선 예제에서 얼음을 먼저 푼 후 커피를 내린다는 점에서 동일하게 
보이기 때문입니다.

동기성이란 앞서 진행한 작업의 완료 여부를 확인하는 것이라고 하였습니다. 

하지만 완료 여부를 꼭 블로킹 방식으로 확인할 필요는 없습니다.

커피를 내리고 얼음을 다펐다면 두개를 합쳐서 결과물을 만들어야 합니다. 

알바생1은 자신의 작업을 완료한 이후에 얼음이 다퍼졌는지를 확인한 후 두개를 
합쳐 손님께 제공해야 합니다.

해당 상황을 코드로 표현하면 아래와 같습니다.

```swift
import Foundation

func makeCoffee() {
    for index in 0..<6 {
        print("커피 내림☺️: \(20 * index)%")
        sleep(1)
    }
    print("알바생1: 얼음을 다펐습니다!!")
    isIceFinished = true
}

func scoopIce() {
    for index in 0..<5 {
        print("얼음 푸기❄️: \(25 * index)%")
        sleep(1)
    }
    print("알바생1: 커피다내렸어요!!")
    isCoffeeFinished = true
}

var isCoffeeFinished = false
var isIceFinished = false

var iceOperation = BlockOperation(block: scoopIce)

OperationQueue().addOperations([iceOperation], waitUntilFinished: false)

makeCoffee()

while(!isCoffeeFinished && !isIceFinished) {
    sleep(1)
}
print("커피가 완성됬습니다.")
```

알바생2가 얼음을 다펐다면 `isIceFinished` 변수에 `true` 가 할당됩니다.

그리고 그것은 아래 `while` 문에 의해 확인되고 커피가 완성됩니다.

즉, 완료 여부가 확인된다는 점에서 얼음을 푸는 작업은 동기작업입니다. 
동시에 논블로킹이지요.

# 사용

동기 비동기 논블로킹 블로킹에 대한 개념적인 부분을 살펴보았습니다.

여기까지 보면 논블로킹 비동기가 좋은 것이다 라고 생각하실 수도있을 것 
같습니다.

하지만 앞서 블로킹과 동기성의 차이에서 살펴보았듯이 동기적으로 작동한다고 
멀티쓰레딩을 사용하지 못하는 것이 아닙니다.

각각의 컨셉들의 특성에 맞춰 작업처리를 설계하는 것이 중요합니다.

예를들어 멀트쓰레딩은 말그대로 여러개의 쓰레드에서 작업이 동시에 수행되는 
것을 가능하게 합니다.

하지만 쓰레드를 생성하는 행위는 추가적인 리소스를 필요로함으로 상황에 맞춰 
적절한 수의 쓰레드를 생성하는 것이 중요합니다.

# Race condition

마지막으로 멀티쓰레드 환경에서 발생할 수 있는 대표적인 문제인 Race 
condition에 대해 알아보겠습니다.

자원을 공유하지 않는 멀트 프로세스 방식과 달리 멀트쓰레드는 각 쓰레드 간에 
자원을 공유한다는 특징이 있습니다.

이 때 복수의 쓰레드에서 공유자원에 동시에 접근하는 경우 예상치 못한 동작이 
발생할 수 있습니다.

보이시는 코드는 하나의 배열을 3개의 쓰레드에서 동시에 접근하는 코드입니다.

```swift
var array = Array(1...10)

DispatchQueue.global().async {
    for _ in 1...3 {
        print("준영", array.removeFirst())
    }
}

DispatchQueue.global().async {
    for _ in 1...3 {
        print("창훈", array.removeFirst())
    }
}

DispatchQueue.global().async {
    for _ in 1...3 {
        print("동수", array.removeFirst())
    }
}
```

결과를 보시면 해당 배열에는 중복된 값이 없음에도 같은 숫자들이 서로다른 
쓰레드에서 각각 추출된 것을 확인할 있습니다.

이런 상태를 Race Condition이라고 합니다. 공유자원을 사용하는 다중쓰레드 
환경에서 이 문제를 해결하는 것은중요하빈다.
