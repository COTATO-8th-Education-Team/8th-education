객체 지향 디자인 패턴 중 하나인 프록시패턴
프록시를 번역하면  -> 대리자, 대변인 이런 뜻 
즉 누군가에게 어떤 일을 대신 시키는 것을 의미함
프록시 패턴
: 특정 객체의 대리자나 대변인 역할을 하는 프록시 개체를 제공하는 디자인 패턴
프록시 패턴을 사용함으로써 클라이언트는 특정 객체를 직접 참조하여 접근하는 것이 아닌 프록시 객체를 통해 상호작용
프록시는 원래 객체에 대한 접근을 제어하므로 당신의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 함

문제
그렇다면 객체에 대한 접근을 제한하는 이유는 무엇일까요? 
예를 들어 방대한 양의 시스템 자원을 소비하는 거대한 객체가 있다고 가정합시다. 이 객체는 항상 필요한 것은 아니고, 필요할 때가 있기는 합니다.
여러분은 실제로 필요할 때만 이 객체를 만들어서 지연된 초기화를 구현할 수 있습니다. 그러면 객체의 모든 클라이언트들은 어떤 지연된 초기화 코드를 실행해야 하는데 불행히도 이것은 아마도 많은 중복을 초래할 것입니다.
이상적인 상황에서는 이 코드를 객체의 클래스에 직접 넣을 수 있겠지만, 그게 항상 가능한 것은 아닙니다. 예를 들어 그 클래스가 폐쇄된 타사 라이브러리의 일부일 수 있습니다.
해결책
프록시 패턴은 원래 서비스 객체와 같은 인터페이스로 새 프록시 클래스를 생성하려고 제안합니다. 그러면 프록시 객체를 원래 객체의 모든 클라이언트들에 전달하도록 앱을 업데이트할 수 있습니다. 클라이언트로부터 요청을 받으면 이 프록시는 실제 서비스 객체를 생성하고 모든 작업을 이 객체에 위임합니다.
그러나 이것들은 무슨 소용이 있는지 궁금하실 것입니다. 당신이 클래스의 메인 로직 이전이나 이후에 무언가를 실행해야 하는 경우 프록시는 해당 클래스를 변경하지 않고도 이 무언가를 수행할 수 있도록 합니다. 프록시는 원래 클래스와 같은 인터페이스를 구현하므로 실제 서비스 객체를 기대하는 모든 클라이언트에 전달될 수 있습니다.
실제상황 적용
신용 카드는 은행 계좌의 프록시이며, 은행 계좌는 현금의 프록시입니다. 둘 다 같은 인터페이스를 구현하며 둘 다 결제에 사용될 수 있습니다. 신용 카드를 사용하는 소비자는 많은 현금을 가지고 다닐 필요가 없어서 기분이 좋습니다. 또한 상점 주인은 거래 수입을 은행에 가는 길에 강도를 당하거나 잃어버릴 위험 없이 계좌에 전자적으로 입금이 되기 때문에 기분이 좋습니다.
구조(그림 설명)
프록시 패턴은 클라이언트가 접근할 Subject와 이에 대한 구현체인 RealSubject, Proxy가 존재합니다. 
Subject: Proxy와 RealSubject가 모두 구현하는 인터페이스로 클라이언트가 프록시와 실제 대상을 동일하게 다룰 수 있도록 정의합니다.
RealSubject : 클라이언트가 직접 상호작용하는 실제 객체입니다.
Proxy : RealSubject를 감싸며 실제 작업을 수행하는 주체로 클라이언트와 RealSubject 사이에 위치한 중간 객체다. RealSubject의 같은 이름의 메서드를 호출하며, 클라이언트의 요청을 처리하기 전이나 후에 추가적인 작업을 수행할 수 있습니다.
코드예제(코드 설명)
이미지 뷰어 프로그램을 만든다고 가정해봅시다. 이미지 뷰어는 고해상도의 이미지를 불러와 사용자에게 보여줍니다.
고해상도 이미지 경로를 인자로 받아 메모리에 적재하고, showImage() 메소드가 호출하면 화면에 렌더링 하는 HighREsolutionImage 클래스를 다음과 같이 구성해 주었습니다.
먼저 프록시 패턴을 적용하지 않은 코드에서느 HighREsolutionImage 클래스를 이미지 뷰어인 ImageViewr 클래스에서 이미지 3개를 등록하고 다음과 같이 로드한다고 합니다.
그러나 이 코드를 실행하면 이미지를 준비하는 과정에서 시간을 다 빼앗습니다. 그런데 가만 생각해보면 만일 사용자가 목록에서 이미지를 선택하기 전까지 굳이 이미지를 메모리에 준비시킬 필요가 없을 것입니다. 즉 사용자가 목록에서 선택한 이미지만 로딩시키면 되지 않을까요?
이제 프록시 패턴을 적용한 코드를 보여드리겠습니다.
즉, 프록시 클래스에서 사용자가 선택한 이미지만 로드해서 렌더링하도록 대상 객체를 제어를 하면 되는 것입니다. 가상 프록시를 이용해  늦은 초기화(Lazy Initialisation)로 실제 객체의 사용 시점을 제어해보도록 합시다. 참고로 HighResolutionImage 클래스가 대상 객체(RealSubject) 가 됩니다.
프록시를 구현하는데 있어 가장 먼저 해야할 일은, 대상 객체와 프록시 객체를 하나로 묶어주는 인터페이스를 정의하는 것인데 이는 다형성을 이용해 대상, 프록시 객체 모두를 하나의 타입으로 다루기 위해서입니다.
이미지 뷰어 클래스(클라이언트)의 코드 자체는 크게 변하지 않았는데요 똑같이 이미지 3개를 로드하는 코드인데, 대상 객체 대신에 프록시 객체에 할당한 점이 다를 뿐입니다. 하지만 내부 동작 방식은 크게 변경되었는데, 프록시 객체 내에서 경로 데이터를 지니고 있다가 사용자가 showImage를 호출하면 그때서야 대상 객체를 로드(lazyload)하여, 이미지를 메모리에 적재하고 대상 객체의 showIMage() 메서드를 위임 호출함으로써, 실제 메소드를 호출하는 시점에 메모리 적재가 이루어지기 때문에 불필요한 자원낭비가 발생하지 않게 되었습니다.
장단점
먼저 장점에 대해 설명드리자면 개방폐쇄원칙을 준수하기 때문에 기존 대상 객체의 코드를 변경하지 않고 새로운 기능을 추가할 수 있습니다 그리고 단일 책임 원칙을 준수하기 때문에 대상 객체는 자신의 기능에만 집중 하고, 그 이외 부가 기능을 제공하는 역할을 프록시 객체에 위임하여 다중 책임을 회피 할 수 있습니다. 사용자 입장에서는 프록시 객체나 실제 객체나 사용법은 유사하므로 사용성에 문제 되지 않습니다. 그다음으로 단점에 대해 설명드리자면 많은 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가할 수 있습니다. 예를 들어 여러 클래스에 로깅 기능을 가미 시키고 싶다면, 동일한 코드를 적용함에도 각각의 클래스에 해당되는 프록시 클래스를 만들어서 적용해야 되기 때문에 코드량이 많아지고 중복이 발생되는 것이죠. 프록시 클래스 자체에 들어가는 자원이 많다면 서비스로부터의 응답이 늦어질 수 있구요. 객체를 생성할 때 한 단계를 거치게 되므로 빈번한 객체 생성이 필요한 경우나 객체 생성을 위해 스레드 생성 및 동기화가 구현되어 있는 경우 성능이 저하될 수 있습니다.



